1. 다양한  ubuntu os 및 하드웨어 환경에 따라 tas를 배포할 줄 알아야 합니다. 현재 pc개발환경뿐만 아니라 다른 버전 os와 하드웨어에서도 tas를 배포 및 포팅하는 방법을 숙지하시길 바랍니다.
- tas 개발환경 setting 복습

2. # 주의 사항using namespace std; 와 같은 어떠한 이름 공간을 사용하겠다라고 선언하는 것은 권장되지 않음. -> std에 이름이 겹치는 함수를 만들게 된다면, 오류 발생
따라서, 권장하는 방식은 using namespace std;를 사용하지 않고 std::를 직접 앞에 붙여서 std의 이름 공간 함수라고 명시해주는 것이 좋음.
당연하다고 생각하지만 tas에서 가장 기본적으로 적용되는 원칙입니다. 위와 같은 이유를 잘 파악하고 코드 파악 및 작성을 해야 합니다.
-> using namespace std1;, using namespace std2;
-> std1, std2 두 개의 라이브러리를 사용한다고 가정했을 때 std1, std2 두 라이브러리 안에 dfs() 라는 함수가 들어있다면 dfs함수를 불러 올 때 충돌이 일어나게 된다


3. 경묵님이 알려주신 여러 기본 개념을 잘 파악해야합니다. 그중 교통 관련 개념 및 프로젝트 관련 정보는 추가로 교육예정입니다.

4. * 외부 변수의 레퍼런스 리턴    int& function(int& a) {    a = 5;    return a;    }
    int main() {    int b = 2;    int c = function(b);    return 0;    }    -> 가능-> function(b)를 실행한 시점으로 부터 a는 main의 b를 참조--> function이 리턴한 참조자는 아직 살아있는 변수인 b를 참조---> 즉, int c = 5; 가 됨
* 값을 리턴하는 함수를 참조자로 받기    int function() {    int a = 5;    return a;    }
    int main() {    int& c = function();    return 0;    }    -> 불가능-> 리턴값은 해당 문장이 끝난 후 바로 사라지는 값이기 때문-> 하지만 const int& c = function(); -> 가능
위 내용은 실제 구현을 하면서 쉽게 실수할 수 있는 내용입니다.  잘 숙지하고 버그가 나오지 않도록 해야하는 부분입니다.

5. CODE 14 -> new[] 을 이용해 할당 하였기 때문에 delete[] 를 통해 해제 -> 즉, new - delete 짝을 이룸 (new[] - delete[])
위 부분이 그냥 지나갈 수 있지만, c++에서 동적할당 메모리의 회수가 중요하다는걸 이해하고 가셔야 합니다.
-> new는 힙에 메모리할당과 성성자를 호출해주고 해당 타입으로 변환까지 해준다.
즉, new -> 1. 메모리 할당, 2. 생성자 호출 3. 타입변환
-> delete 역할 1. 소멸자 호출, 2. 메모리 해제

6. 현재 tas에서 사용하고 있는 public, private 변수 및 함수 명칭 규칙을 경묵님을 통해 확인해보시길바랍니다. 더불어서 PascalCase, camelCase, snake_case 표기법에 대해서도 학습하시길 바랍니다.

7. 함수 오버로딩과 오버라이딩을 잘 구분하시고 학습 진행하시길 바랍니다.
-> 함수 오버로딩 (함수 중복 정의) -> 같은 이름의 함수에 매개변수를 다르게 사용하여 매개 변수에 따라 다른 함수가 실행되는 것
-> 함수 오버라이딩 (함수 재정의) -> 상속받았을 때 부모클래스의 함수를 사용하지 않고 다른 기능을 실행할 때 함수를 자식클래스에 같은 이름, 매개변수로 재정의해서 사용하는 것