# 링킹 (Linking)
    -> 서로 다른 파일에 흩어져 있던 함수나 클래스들을 한데 묶어서 링크해주는 작업
    -> 컴파일 이후, 실행하기 이전에 작성한 프로그램이 사용하는 다른 프로그램이나 라이브러리를 가져와 연결하는 과정
    -> main함수 안에 foo가 어디에 정의되어 있는지 위치를 찾고, 제대로 된 함수를 호출

* 정적 링크 - static Linking
    -> 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사
        - 자신이 작성한 프로그램에서 A라는 외부 함수를 사용 -> A라는 외부 함수에 댛나 정보를 자신이 작성한 프로그램의 실행파일을 만들 때 복사

    ex1) 5개의 프로그램에서 A라는 외부 함수를 이용하는데
        -> 정적 링크 방식을 사용하면 5개의 프로그램의 실행 가능한 목적파일 각각에 A의 정보가 담김 -> 중복 발생 -> 정적 링킹으로 만들어진 프로그램의 크기가 크고 메모리 효율 X
        
    또한,
    정적 링킹을 이용하면, A라는 함수에 변화가 생길 경우 그 변화를 적용하기 위해 다시 컴파일하여 다시 링킹을 해야함.
    -> 실행 가능한 목적파일을 만들 때 A에 관한 정보를 그냥 복사해왔기 때문에 A에 변화가 생겨도 다시 컴파일하지 않는 이상 변화가 적용되지 않음

    장점
    1. 동적 링킹보다 빠르다.
    2. 정적 링킹 프로그램에서 모든 코드는 하나의 실행 모듈에 담기기 때문에
        -> 불일치에 대한 걱정을 하지 않아도 된다.

* 동적 링크 - Dynamic Linking
    -> 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하지 않고 해당 모듈의 주소만을 가짐
        -> 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로 가서 필요한 것을 들고 오는 방식
    
    ex1) 5개의 프로긁매에서 A라는 외부 함수를 이용하는데
        -> A라는 함수의 정보는 하나만 있으면 됨.
            -> 각각의 실행 가능한 목적파일에서는 A를 복사해서 A 그 자체를 가지고 있는 것이 아니라 A가 있는 곳의 주소만 가리키고 있기 때문 -> 메모리와 디스크 공간 아낄 수 있음.

    또한, 
    동적 링킹을 이용하면, A라는 함수에 변화가 생겨도 변화를 적용하기 위해 다시 컴파일하여 다시 링킹할 필요가 업다.
        -> A의 정보를 복사한 것이 아니라, 주소를 담았기 때문
    동적 라이브러리가 메모리에 이미 존재하는 경우 로드되는 시간을 단축시킬 수 있다.

    하지만, 정적 링킹 보다 느림 -> 매번 주소를 따라가야하는 오버헤드가 존재

    문제점
    1. 불일치에 대한 문제를 고려해야 한다.
    -> 예를 들어 어떤 프로그램에서 A라는 함수를 동적 링킹 방식으로 사용하고 있을 때, A라는 함수가 시스템에서 제거되면 이는 불일치 상황
    -> 해당 프로그램의 실행 가능 목적파일에는 A의 주소가 있어서 마치 A가 존재하는 것처럼 움직이지만 실제 A는 시스템에 더이상 존재하지 않기 때문
    -> 따라서 프로그램은 제대로 실행 X
